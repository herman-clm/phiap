---
title: "Diagnosis Code - ALDO Dx V2"
output:
  html_document: default
  pdf_document: default
---

```{r setup, include=FALSE, echo=FALSE, cache=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(dplyr)
library(data.table)
library(tibble)
setwd("~/repos/Daniel_Herman_Aldosterone_2017_03/code/R/PA_analysis")
source("../common_anal/R_fxns.R")
source("../common_anal/ALDO_Dx_fxns.R")
```
Load in HERMANDA_ALDO_DX_V2.csv file that contains Dx.


## HERMANDA_ALDO_DX_V2.csv
```{r read in raw data file, echo=FALSE, cache=TRUE}

# Load in HERMANDA_ALDO_DX_V2.csv file that contains Dx and encounter info

dx <- prep_aldo_dx(dat_file = "/data/raw_data/PA/HERMANDA_ALDO_DX_V2.csv")

```
Check for duplicates (should be in prep_aldo_dx function):
```{r check & remove duplicates}
which(duplicated(dx))
which(duplicated(dx, fromLast = TRUE))


# tt is a full list of duplicated rows
# temp <- which(duplicated(dx))
# temp2 <- which(duplicated(dx, fromLast = TRUE))
# View(dx[c(temp, temp2),] %>% arrange(EMPI, SOURCE_LAST_UPDATE_DATE))
# tt <- dx[c(temp, temp2),] %>% arrange(EMPI, SOURCE_LAST_UPDATE_DATE)
# write.csv(tt, file = "/home/chart_review/Duplicated.csv")


# remove duplicates (keep first)
dx <- dx[!duplicated(dx),]
```
Need to check db/query for reason.


```{r}
length(unique(dx$EMPI))
length(unique(dx$PK_ENCOUNTER_ID))
```
There are 843 unique EMPI's, 5696 unique PK_ENCOUNTER_ID.


Check COMMENTS for Liddle's Syndrome
```{r Check COMMENTS for Liddle's Syndrome}
dx %>% group_by(COMMENTS) %>%
  summarise(N=n()) %>%
  print.data.frame()
```

DX_TYPE: Type of diagnosis being referenced: Admitting, Discharge, Final. Largely missing here:
```{r DX_TYPE}
table(dx$DX_TYPE)
```
No this information in Chart Review.

PATIENT_MASTER_CLASS: provides more useful info about Inpatient/Outpatient/ED. 1 missing (from Radiology). Most of encounters are from OUTPATIENT.
```{r PATIENT_MASTER_CLASS}
table(dx$DX_TYPE,dx$PATIENT_MASTER_CLASS)
```

Check MASTER_LOCATION_FACILITY_YN/MASTER_LOCATION_CLINIC_YN
```{r Check for Location Facility/Clinic}
# sum for Facility
sum(dx$MASTER_LOCATION_FACILITY_YN) # NA here
sum(dx$MASTER_LOCATION_FACILITY_YN, na.rm = TRUE) # 429

# sum for Clinic
sum(dx$MASTER_LOCATION_CLINIC_YN) # NA here
sum(dx$MASTER_LOCATION_CLINIC_YN, na.rm = TRUE) # 5446

# Complimentary?
which(dx$MASTER_LOCATION_FACILITY_YN == dx$MASTER_LOCATION_CLINIC_YN)
```
Location Facility/Clinic are complimentary. (1 NA)


```{r ICD9/10 codes}
table(dx$CODE, dx$CODE_STANDARD_NAME)
```

Check ADMIT_SOURCE:
```{r ADMIT_SOURCE}
table(dx$ADMIT_SOURCE, dx$PATIENT_MASTER_CLASS)
```


ENC_TYPE_CODE is well defined within ENC_TYPE_MASTER_CODE
```{r ENC_TYPE_MASTER_CODE/ENC_TYPE_CODE}
dx %>% group_by(ENC_TYPE_MASTER_CODE, ENC_TYPE_CODE) %>%
  summarise(N=n()) %>%
  arrange(ENC_TYPE_MASTER_CODE) %>%
  print.data.frame()
```


Providers
-- ROLE: roles from ADMIT to ATTEND are crossed someway.
```{r}
dx %>% group_by(ROLE_ADMIT, ROLE_ATTEND) %>%
  summarise(N=n()) %>%
  arrange(ROLE_ADMIT) %>%
  print.data.frame()
```

-- NPI
```{r NPI from ADMIT and ATTEND}
sum(dx$NPI_ADMIT == dx$NPI_ATTEND, na.rm = TRUE)
```
There are 4834 encounters where same Provide served as both ADMIT and ATTEND provider.

#### Apply Criteria of >=2 Dx
For each patient (EMPI), count distinct PK_ENCOUNTER_ID for PA Dx and put the EMPI and count into tibble `empi`.
```{r Get EMPI for 2 or more Dx}
empi <- dx %>% group_by(EMPI) %>%
  summarise(N=n_distinct(PK_ENCOUNTER_ID)) %>%
  arrange(desc(N)) %>%
  filter(N >= 2) %>%
  print.data.frame()
```
```{r subset dx based on Criteria}
dx_1 <- dx %>% filter(EMPI %in% empi$EMPI)
```
Chart review on them to make sure the accuracy.
chart_review_ALDO_Dx_V2.txt (1)


Now aggregate Dx into ENCOUNTER Level, using `PK_ENCOUNTER_ID`.

-- When `DX_TYPE == "Admitting"`, does this `PK_ENCOUNTER_ID` always come with "Final"? If so, it is safe to remove "Admitting", because we can always use "Final".
```{r Check pairs of "Admitting" and "Final", and remove "Admitting"}
# get PK_ENCOUNTER_ID which has DX_TYPE == "Admitting"
admitting_pk <- dx_1 %>% filter(DX_TYPE == "Admitting") %>%
    distinct(PK_ENCOUNTER_ID)
  
admit_final <- dx_1 %>% filter(PK_ENCOUNTER_ID %in% admitting_pk$PK_ENCOUNTER_ID) %>%
          filter(DX_TYPE %in% c("Final", "Admitting")) %>%
          group_by(PK_ENCOUNTER_ID) %>%
          summarise(N = n_distinct(DX_TYPE)) %>%
          filter(N == 2)

dx_1 <- dx_1 %>% filter(!(PK_ENCOUNTER_ID %in% admit_final$PK_ENCOUNTER_ID & DX_TYPE == "Admitting"))

```


Check Duplicate Dx for each PK_ENCOUNTER_ID
```{r Check Duplicated Dx for each PK_ENCOUNTER_ID}

ck <- dup_dx_pk_YN(dx_1)


tp <- ck[[2]] %>% filter(N != dis_N)  ## 109 PK_ENCOUNTER_ID which has duplicated Dx's

## But for those PK_ENCOUNTER_ID, there are 220 unique rows
dup_dx <- dx_1 %>% filter(PK_ENCOUNTER_ID %in% tp$PK_ENCOUNTER_ID) 



# What is the difference?
length(unique(paste(dup_dx$CODE, dup_dx$PK_ENCOUNTER_ID)))   # 109
length(unique(paste(dup_dx$CODE, dup_dx$PK_ENCOUNTER_ID, dup_dx$COMMENTS, dup_dx$DX_TYPE, dup_dx$PRIMARY_YN, dup_dx$DX_SEQUENCE)))    # 220

```
So for these duplicated Dx's, there are differences in DX_TYPE, COMMENTS, PRIMARY_YN, and DX_SEQUENCE.


Decision: For each PK_ENCOUNTER_ID, if everything is the same for one CODE (duplicated Dx's), except for DX_TYPE, COMMENTS, PRIMARY_YN, and DX_SEQUENCE, then:
(1) Select DX_TYPE == "Final", if exists. If not,
(2) Select PRIMARY_YN == TRUE. If same, then
(4) Select the one with smaller DX_SEQUENCE. If same, then,
(3) Check COMMENTS, select the one which is not null. If same (case-insensative), select the one with all Caps. If not same...???

```{r Apply decision above}
dx_1 <- dup_dx_pk_RM(dx_1)
```



Check duplicated Dx's again:
```{r ck duplicated Dxs again}
dup_dx_pk_YN(dx_1)$res
```
 Now, we end up with a PK_ENCOUNTER_ID leve Dx data.


```{r Use functions to to the cleaning from the beginning}
rm(list=ls())

library(dplyr)
library(data.table)
library(tibble)
setwd("~/repos/Daniel_Herman_Aldosterone_2017_03/code/R/PA_analysis")

source("../common_anal/ALDO_Dx_fxns.R")

dx <- prep_aldo_dx()
dx <- agg_dx_pk_enc(dx)


```


